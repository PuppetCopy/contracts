// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.29;

// import {DataStore, Oracle, Price} from "@gmx/contracts/oracle/Oracle.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {Test} from "forge-std/src/Test.sol";
import {console} from "forge-std/src/console.sol";

import {GmxExecutionCallback} from "src/position/GmxExecutionCallback.sol";
import {MatchingRule} from "src/position/MatchingRule.sol";
import {MirrorPosition} from "src/position/MirrorPosition.sol";
import {IGmxExchangeRouter} from "src/position/interface/IGmxExchangeRouter.sol";
import {AllocationStore} from "src/shared/AllocationStore.sol";
import {Dictatorship} from "src/shared/Dictatorship.sol";
import {FeeMarketplace} from "src/shared/FeeMarketplace.sol";
import {FeeMarketplaceStore} from "src/shared/FeeMarketplaceStore.sol";
import {TokenRouter} from "src/shared/TokenRouter.sol";
import {PuppetToken} from "src/tokenomics/PuppetToken.sol";
import {BankStore} from "src/utils/BankStore.sol";
import {Error} from "src/utils/Error.sol";

import {Const} from "script/Const.sol";

interface IChainlinkPriceFeedProvider {
    struct ValidatedPrice {
        address token;
        uint min;
        uint max;
        uint timestamp;
        address provider;
    }

    /// @notice Gets the oracle price for a given token using Chainlink price feeds
    /// @dev The timestamp returned is based on the current blockchain timestamp
    /// @param token The token address to get the price for
    /// @param data Additional data (unused in this implementation)
    /// @return The validated price with min/max prices, timestamp, and provider address
    function getOraclePrice(address token, bytes memory data) external view returns (ValidatedPrice memory);
}

contract TradingForkTest is Test {
    // Real Arbitrum addresses
    IERC20 constant USDC = IERC20(Const.usdc);
    IERC20 constant WETH = IERC20(Const.wnt);

    // Test contracts
    Dictatorship dictator;
    TokenRouter tokenRouter;
    PuppetToken puppetToken;
    AllocationStore allocationStore;
    MatchingRule matchingRule;
    GmxExecutionCallback gmxExecutionCallback;
    FeeMarketplace feeMarketplace;
    FeeMarketplaceStore feeMarketplaceStore;
    MirrorPosition mirrorPosition;

    // Test users
    address owner = makeAddr("owner");
    address trader = makeAddr("trader");
    address puppet1 = makeAddr("puppet1");
    address puppet2 = makeAddr("puppet2");

    uint internal nextAllocationId = 0;

    function getNextAllocationId() internal returns (uint) {
        return ++nextAllocationId;
    }

    function setUp() public {
        vm.createSelectFork(vm.envString("RPC_URL"));
        vm.rollFork(340881246);

        vm.startPrank(owner);

        // Deploy core contracts
        dictator = new Dictatorship(owner);
        tokenRouter = new TokenRouter(dictator, TokenRouter.Config(200_000));
        dictator.initContract(tokenRouter);
        puppetToken = new PuppetToken();

        // Deploy position contracts
        feeMarketplaceStore = new FeeMarketplaceStore(dictator, tokenRouter, puppetToken);
        feeMarketplace = new FeeMarketplace(
            dictator,
            puppetToken,
            feeMarketplaceStore,
            FeeMarketplace.Config({
                distributionTimeframe: 1 days,
                burnBasisPoints: 10000, // 100% burn
                feeDistributor: BankStore(address(0))
            })
        );
        allocationStore = new AllocationStore(dictator, tokenRouter);
        matchingRule = new MatchingRule(
            dictator,
            allocationStore,
            MatchingRule.Config({
                minExpiryDuration: 1 days,
                minAllowanceRate: 100, // 1%
                maxAllowanceRate: 10000, // 100%
                minActivityThrottle: 1 hours,
                maxActivityThrottle: 30 days
            })
        );
        gmxExecutionCallback = new GmxExecutionCallback(
            dictator,
            GmxExecutionCallback.Config({
                mirrorPosition: MirrorPosition(_getNextContractAddress(msg.sender)),
                refundExecutionFeeReceiver: Const.orderflowHandler
            })
        );
        mirrorPosition = new MirrorPosition(
            dictator,
            allocationStore,
            MirrorPosition.Config({
                gmxExchangeRouter: IGmxExchangeRouter(Const.gmxExchangeRouter),
                callbackHandler: address(gmxExecutionCallback),
                gmxOrderVault: Const.gmxOrderVault,
                referralCode: bytes32("PUPPET"),
                increaseCallbackGasLimit: 2_000_000,
                decreaseCallbackGasLimit: 2_000_000,
                maxPuppetList: 50,
                maxKeeperFeeToAllocationRatio: 0.1e30, // 10%
                maxKeeperFeeToAdjustmentRatio: 0.1e30 // 5%
            })
        );

        // Set up permissions
        dictator.setPermission(tokenRouter, tokenRouter.transfer.selector, address(allocationStore));
        dictator.setPermission(tokenRouter, tokenRouter.transfer.selector, address(feeMarketplaceStore));
        dictator.setAccess(allocationStore, address(matchingRule));
        dictator.setAccess(allocationStore, address(mirrorPosition));
        dictator.setAccess(allocationStore, address(feeMarketplace));
        dictator.setAccess(feeMarketplaceStore, address(feeMarketplace));

        dictator.setPermission(mirrorPosition, mirrorPosition.requestMirror.selector, owner);
        dictator.setPermission(mirrorPosition, mirrorPosition.requestAdjust.selector, owner);
        // TODO: Update when Allocation contract is available in test
        // dictator.setPermission(allocation, allocation.settle.selector, owner);
        dictator.setPermission(mirrorPosition, mirrorPosition.execute.selector, owner);
        // TODO: Update when Allocation contract is available in test
        // dictator.setPermission(allocation, allocation.setTokenDustThresholdList.selector, owner);
        // TODO: Update when Allocation contract is available in test
        // dictator.setPermission(
        //     allocation, allocation.initializeTraderActivityThrottle.selector, address(matchingRule)
        // );

        dictator.setPermission(matchingRule, matchingRule.setRule.selector, owner);
        dictator.setPermission(matchingRule, matchingRule.deposit.selector, owner);
        dictator.setPermission(matchingRule, matchingRule.setTokenAllowanceList.selector, owner);
        dictator.initContract(matchingRule);

        dictator.setPermission(feeMarketplace, feeMarketplace.deposit.selector, address(mirrorPosition));
        dictator.setPermission(feeMarketplace, feeMarketplace.setAskPrice.selector, owner);

        // Set allowed tokens
        IERC20[] memory allowedTokens = new IERC20[](2);
        allowedTokens[0] = USDC;
        allowedTokens[1] = WETH;

        uint[] memory allowanceCaps = new uint[](2);
        allowanceCaps[0] = 1000e6; // 1000 USDC
        allowanceCaps[1] = 1e18; // 1 ETH

        matchingRule.setTokenAllowanceList(allowedTokens, allowanceCaps);

        // Initialize FeeMarketplace
        dictator.initContract(feeMarketplace);

        // Set ask price for USDC
        feeMarketplace.setAskPrice(USDC, 100e18);

        // Initialize MirrorPosition
        dictator.initContract(mirrorPosition);

        // Set dust thresholds
        uint[] memory dustThresholds = new uint[](2);
        dustThresholds[0] = 1e6; // 1 USDC
        dustThresholds[1] = 0.001e18; // 0.001 ETH

        // TODO: Update when Allocation contract is available in test
        // allocation.setTokenDustThresholdList(allowedTokens, dustThresholds);
        // Fund test accounts with real tokens
        vm.deal(owner, 100 ether);

        deal(address(WETH), owner, 100 ether);
        WETH.approve(address(tokenRouter), type(uint).max);
        matchingRule.deposit(WETH, owner, puppet1, 0.1 ether);
        matchingRule.deposit(WETH, owner, puppet2, 0.1 ether);

        deal(address(USDC), owner, 10000e6);
        USDC.approve(address(tokenRouter), type(uint).max);
        matchingRule.deposit(USDC, owner, puppet1, 100e6);
        matchingRule.deposit(USDC, owner, puppet2, 100e6);
        vm.stopPrank();
    }

    // function testForkOpenPosition() public {
    //     vm.startPrank(owner);

    //     // Create puppet list
    //     address[] memory puppetList = new address[](2);
    //     puppetList[0] = puppet1;
    //     puppetList[1] = puppet2;

    //     // Set up matching rules for puppets
    //     matchingRule.setRule(
    //         mirrorPosition,
    //         USDC,
    //         puppet1,
    //         trader,
    //         MatchingRule.Rule({
    //             allowanceRate: 1000, // 10%
    //             throttleActivity: 1 hours,
    //             expiry: block.timestamp + 30 days
    //         })
    //     );

    //     matchingRule.setRule(
    //         mirrorPosition,
    //         USDC,
    //         puppet2,
    //         trader,
    //         MatchingRule.Rule({
    //             allowanceRate: 1500, // 15%
    //             throttleActivity: 1 hours,
    //             expiry: block.timestamp + 30 days
    //         })
    //     );

    //     // Encode and execute the call
    //     IChainlinkPriceFeedProvider.ValidatedPrice memory price =
    //         IChainlinkPriceFeedProvider(Const.chainlinkPriceFeedProvider).getOraclePrice(Const.wnt, "");

    //     // Create position call parameters
    //     uint allocationId = getNextAllocationId();
    //     MirrorPosition.CallPosition memory callParams = MirrorPosition.CallPosition({
    //         collateralToken: USDC,
    //         trader: trader,
    //         market: Const.gmxEthUsdcMarket, // ETH/USD market
    //         keeperFeeReceiver: owner,
    //         isIncrease: true,
    //         isLong: true,
    //         executionFee: 0.001 ether, // GMX execution fee
    //         collateralDelta: 100e6, // 100 USDC
    //         sizeDeltaInUsd: 1000e30, // 1000 USD position (10x leverage)
    //         acceptablePrice: price.min * 110, // 10% slippage
    //         triggerPrice: price.min,
    //         keeperExecutionFee: 1e6, // 1 USDC keeper fee
    //         allocationId: allocationId
    //     });

    //     // Check initial balances
    //     uint puppet1BalanceBefore = allocationStore.userBalanceMap(USDC, puppet1);
    //     uint puppet2BalanceBefore = allocationStore.userBalanceMap(USDC, puppet2);

    //     console.log("Puppet1 balance before:", puppet1BalanceBefore);
    //     console.log("Puppet2 balance before:", puppet2BalanceBefore);

    //     // Request mirror position
    //     (address allocationAddress, bytes32 requestKey) =
    //         mirrorPosition.requestMirror{value: callParams.executionFee}(matchingRule, callParams, puppetList);

    //     console.log("Allocation address:", allocationAddress);
    //     console.log("Allocation ID:", allocationId);
    //     console.log("Request key:", vm.toString(requestKey));

    //     // Check allocations
    //     uint puppet1Allocation = mirrorPosition.allocationPuppetArray(allocationAddress, 0);
    //     uint puppet2Allocation = mirrorPosition.allocationPuppetArray(allocationAddress, 1);
    //     uint totalAllocation = mirrorPosition.getAllocation(allocationAddress);

    //     console.log("Puppet1 allocation:", puppet1Allocation);
    //     console.log("Puppet2 allocation:", puppet2Allocation);
    //     console.log("Total net allocation:", totalAllocation);

    //     // Verify allocations are correct
    //     assertGt(puppet1Allocation, 0, "Puppet1 should have allocation");
    //     assertGt(puppet2Allocation, 0, "Puppet2 should have allocation");
    //     assertEq(
    //         totalAllocation,
    //         puppet1Allocation + puppet2Allocation - callParams.keeperExecutionFee,
    //         "Net allocation should be gross minus keeper fee"
    //     );

    //     // Check balances were deducted
    //     uint puppet1BalanceAfter = allocationStore.userBalanceMap(USDC, puppet1);
    //     uint puppet2BalanceAfter = allocationStore.userBalanceMap(USDC, puppet2);

    //     assertEq(puppet1BalanceAfter, puppet1BalanceBefore - puppet1Allocation, "Puppet1 balance should be reduced");
    //     assertEq(puppet2BalanceAfter, puppet2BalanceBefore - puppet2Allocation, "Puppet2 balance should be reduced");

    //     // Execute the position (simulate GMX callback)
    //     mirrorPosition.execute(requestKey);

    //     // Check position was created
    //     MirrorPosition.Position memory position = mirrorPosition.getPosition(allocationAddress);
    //     assertEq(position.traderSize, callParams.sizeDeltaInUsd, "Trader size should match");
    //     assertEq(position.traderCollateral, callParams.collateralDelta, "Trader collateral should match");
    //     assertGt(position.size, 0, "Mirror position size should be > 0");

    //     console.log("Position created successfully!");
    //     console.log("Trader size:", position.traderSize);
    //     console.log("Trader collateral:", position.traderCollateral);
    //     console.log("Mirror size:", position.size);

    //     vm.stopPrank();
    // }

    function testForkDecreasePosition() public {
        vm.startPrank(owner);

        // Create puppet list with different allocation rates
        address[] memory puppetList = new address[](2);
        puppetList[0] = puppet1;
        puppetList[1] = puppet2;

        // Set up asymmetric matching rules to test proportional decreases
        // TODO: Update when Allocation contract is available in test
        // matchingRule.setRule(
        //     allocation,
        //     USDC,
        //     puppet1,
        //     trader,
        //     MatchingRule.Rule({
        //         allowanceRate: 1000, // 10% allocation rate
        //         throttleActivity: 1 hours,
        //         expiry: block.timestamp + 30 days
        //     })
        // );

        // matchingRule.setRule(
        //     allocation,
        //     USDC,
        //     puppet2,
        //     trader,
        //     MatchingRule.Rule({
        //         allowanceRate: 2000, // 20% allocation rate (2x puppet1)
        //         throttleActivity: 1 hours,
        //         expiry: block.timestamp + 30 days
        //     })
        // );

        // Get ETH price for realistic market conditions
        IChainlinkPriceFeedProvider.ValidatedPrice memory ethPrice =
            IChainlinkPriceFeedProvider(Const.chainlinkPriceFeedProvider).getOraclePrice(Const.wnt, "");

        console.log("ETH Price (min/max):", ethPrice.min, "/", ethPrice.max);

        // STEP 1: Create substantial initial position
        uint allocationId = getNextAllocationId();
        MirrorPosition.CallPosition memory increaseParams = MirrorPosition.CallPosition({
            collateralToken: USDC,
            trader: trader,
            market: Const.gmxEthUsdcMarket,
            keeperFeeReceiver: owner,
            isIncrease: true,
            isLong: true,
            executionFee: 0.001 ether,
            collateralDelta: 200e6, // 200 USDC collateral
            sizeDeltaInUsd: 2000e30, // 2000 USD position (10x leverage)
            acceptablePrice: ethPrice.max * 105 / 100, // 5% slippage tolerance
            triggerPrice: ethPrice.min,
            keeperExecutionFee: 1e6, // 1 USDC keeper fee
            allocationId: allocationId
        });

        // Track initial puppet balances
        uint puppet1InitialBalance = allocationStore.userBalanceMap(USDC, puppet1);
        uint puppet2InitialBalance = allocationStore.userBalanceMap(USDC, puppet2);

        console.log("=== INITIAL POSITION SETUP ===");
        console.log("Puppet1 initial balance:", puppet1InitialBalance);
        console.log("Puppet2 initial balance:", puppet2InitialBalance);

        // Request and execute initial position
        (address allocationAddress, bytes32 initialRequestKey) =
            mirrorPosition.requestMirror{value: increaseParams.executionFee}(matchingRule, increaseParams, puppetList);

        // Verify allocations were made proportionally
        uint puppet1Allocation = mirrorPosition.allocationPuppetArray(allocationAddress, 0);
        uint puppet2Allocation = mirrorPosition.allocationPuppetArray(allocationAddress, 1);
        uint totalAllocation = mirrorPosition.getAllocation(allocationAddress);

        console.log("Puppet1 allocation:", puppet1Allocation);
        console.log("Puppet2 allocation:", puppet2Allocation);
        console.log("Total net allocation:", totalAllocation);

        // Puppet2 should have approximately 2x puppet1's allocation due to 2x allowance rate
        assertApproxEqRel(
            puppet2Allocation, puppet1Allocation * 2, 0.01e18, "Puppet2 should have ~2x puppet1 allocation"
        );

        mirrorPosition.execute(initialRequestKey);

        MirrorPosition.Position memory initialPosition = mirrorPosition.getPosition(allocationAddress);
        assertGt(initialPosition.size, 0, "Initial position size should be > 0");
        assertEq(initialPosition.traderSize, increaseParams.sizeDeltaInUsd, "Initial trader size should match");
        assertEq(
            initialPosition.traderCollateral, increaseParams.collateralDelta, "Initial trader collateral should match"
        );

        console.log("Initial position created:");
        console.log("- Trader size (USD):", initialPosition.traderSize / 1e30);
        console.log("- Mirror size (USD):", initialPosition.size / 1e30);
        console.log("- Trader collateral (USDC):", initialPosition.traderCollateral / 1e6);

        // STEP 2: Perform partial decrease (25% position close)
        MirrorPosition.CallPosition memory partialDecreaseParams = MirrorPosition.CallPosition({
            collateralToken: USDC,
            trader: trader,
            market: Const.gmxEthUsdcMarket,
            keeperFeeReceiver: owner,
            isIncrease: false,
            isLong: true,
            executionFee: 0.001 ether,
            collateralDelta: 50e6, // Reduce collateral by 50 USDC (25% of 200)
            sizeDeltaInUsd: 500e30, // Reduce size by 500 USD (25% of 2000)
            acceptablePrice: ethPrice.min * 95 / 100, // 5% slippage for decrease
            triggerPrice: ethPrice.min,
            keeperExecutionFee: 0.5e6, // 0.5 USDC keeper fee for adjustment
            allocationId: allocationId
        });

        // Track puppet balances before partial decrease
        uint puppet1BalanceBeforePartial = allocationStore.userBalanceMap(USDC, puppet1);
        uint puppet2BalanceBeforePartial = allocationStore.userBalanceMap(USDC, puppet2);

        console.log("\n=== PARTIAL DECREASE (25%) ===");
        console.log("Puppet balances before partial decrease:");
        console.log("- Puppet1:", puppet1BalanceBeforePartial);
        console.log("- Puppet2:", puppet2BalanceBeforePartial);

        bytes32 partialDecreaseKey =
            mirrorPosition.requestAdjust{value: partialDecreaseParams.executionFee}(partialDecreaseParams, puppetList);

        // Verify adjustment request was stored correctly
        MirrorPosition.RequestAdjustment memory partialAdjustmentRequest =
            mirrorPosition.getRequestAdjustment(partialDecreaseKey);
        assertEq(partialAdjustmentRequest.allocationAddress, allocationAddress, "Allocation address should match");
        assertFalse(partialAdjustmentRequest.traderIsIncrease, "Should be decrease");
        assertEq(
            partialAdjustmentRequest.traderSizeDelta, partialDecreaseParams.sizeDeltaInUsd, "Size delta should match"
        );

        mirrorPosition.execute(partialDecreaseKey);

        MirrorPosition.Position memory partialPosition = mirrorPosition.getPosition(allocationAddress);
        uint expectedPartialTraderSize = initialPosition.traderSize - partialDecreaseParams.sizeDeltaInUsd;
        uint expectedPartialTraderCollateral = initialPosition.traderCollateral - partialDecreaseParams.collateralDelta;

        assertEq(
            partialPosition.traderSize, expectedPartialTraderSize, "Partial: Trader size should be reduced correctly"
        );
        assertEq(
            partialPosition.traderCollateral,
            expectedPartialTraderCollateral,
            "Partial: Trader collateral should be reduced correctly"
        );
        assertLt(partialPosition.size, initialPosition.size, "Partial: Mirror position size should be reduced");
        assertGt(partialPosition.size, 0, "Partial: Position should still exist");

        console.log("Position after partial decrease:");
        console.log("- Trader size (USD):", partialPosition.traderSize / 1e30);
        console.log("- Mirror size (USD):", partialPosition.size / 1e30);
        console.log("- Trader collateral (USDC):", partialPosition.traderCollateral / 1e6);

        // Verify proportional reduction in mirror size
        uint expectedMirrorSizeReduction =
            (initialPosition.size * partialDecreaseParams.sizeDeltaInUsd) / initialPosition.traderSize;
        uint actualMirrorSizeReduction = initialPosition.size - partialPosition.size;

        assertApproxEqRel(
            actualMirrorSizeReduction,
            expectedMirrorSizeReduction,
            0.02e18, // 2% tolerance for rounding and fees
            "Mirror position should decrease proportionally"
        );

        // STEP 3: Complete position closure
        MirrorPosition.CallPosition memory closeParams = MirrorPosition.CallPosition({
            collateralToken: USDC,
            trader: trader,
            market: Const.gmxEthUsdcMarket,
            keeperFeeReceiver: owner,
            isIncrease: false,
            isLong: true,
            executionFee: 0.001 ether,
            collateralDelta: partialPosition.traderCollateral, // Close remaining collateral
            sizeDeltaInUsd: partialPosition.traderSize, // Close remaining size
            acceptablePrice: ethPrice.min * 95 / 100,
            triggerPrice: ethPrice.min,
            keeperExecutionFee: 0.5e6,
            allocationId: allocationId
        });

        console.log("\n=== COMPLETE POSITION CLOSURE ===");
        console.log("Closing remaining position:");
        console.log("- Remaining trader size (USD):", partialPosition.traderSize / 1e30);
        console.log("- Remaining trader collateral (USDC):", partialPosition.traderCollateral / 1e6);

        bytes32 closeKey = mirrorPosition.requestAdjust{value: closeParams.executionFee}(closeParams, puppetList);
        mirrorPosition.execute(closeKey);

        // Verify position is completely closed
        MirrorPosition.Position memory finalPosition = mirrorPosition.getPosition(allocationAddress);
        assertEq(finalPosition.traderSize, 0, "Final: Trader size should be 0");
        assertEq(finalPosition.traderCollateral, 0, "Final: Trader collateral should be 0");
        assertEq(finalPosition.size, 0, "Final: Mirror size should be 0");

        console.log("Position completely closed:");
        console.log("- All sizes are now 0");

        // STEP 4: Verify fee deductions were applied correctly
        uint puppet1FinalBalance = allocationStore.userBalanceMap(USDC, puppet1);
        uint puppet2FinalBalance = allocationStore.userBalanceMap(USDC, puppet2);

        console.log("\n=== FINAL BALANCE VERIFICATION ===");
        console.log("Final puppet balances:");
        console.log("- Puppet1:", puppet1FinalBalance);
        console.log("- Puppet2:", puppet2FinalBalance);

        // Calculate total fees paid (keeper fees for all operations)
        uint totalKeeperFees = increaseParams.keeperExecutionFee + partialDecreaseParams.keeperExecutionFee
            + closeParams.keeperExecutionFee;

        // Total balance reduction should be the sum of allocations made
        uint puppet1TotalReduction = puppet1InitialBalance - puppet1FinalBalance;
        uint puppet2TotalReduction = puppet2InitialBalance - puppet2FinalBalance;

        console.log("Total reductions:");
        console.log("- Puppet1:", puppet1TotalReduction);
        console.log("- Puppet2:", puppet2TotalReduction);
        console.log("- Total keeper fees:", totalKeeperFees);

        // Verify that reductions match allocations (balance should be reduced by allocation amount)
        // Since we opened and closed the position, the reduction should equal the initial allocation
        assertEq(puppet1TotalReduction, puppet1Allocation, "Puppet1 total reduction should equal allocation");
        assertEq(puppet2TotalReduction, puppet2Allocation, "Puppet2 total reduction should equal allocation");

        // STEP 5: Test edge case - attempt to adjust non-existent position
        console.log("\n=== EDGE CASE: ADJUST NON-EXISTENT POSITION ===");

        MirrorPosition.CallPosition memory invalidAdjustParams = MirrorPosition.CallPosition({
            collateralToken: USDC,
            trader: trader,
            market: Const.gmxEthUsdcMarket,
            keeperFeeReceiver: owner,
            isIncrease: false,
            isLong: true,
            executionFee: 0.001 ether,
            collateralDelta: 10e6,
            sizeDeltaInUsd: 100e30,
            acceptablePrice: ethPrice.min * 95 / 100,
            triggerPrice: ethPrice.min,
            keeperExecutionFee: 0.5e6,
            allocationId: allocationId // Using same allocation ID but position is closed
        });

        // This should revert because the position is now closed (allocation = 0)
        vm.expectRevert(); // Expecting MirrorPosition__InvalidAllocation error
        mirrorPosition.requestAdjust{value: invalidAdjustParams.executionFee}(invalidAdjustParams, puppetList);

        console.log("Successfully verified edge case handling");
        console.log("\n=== FORK DECREASE POSITION TEST COMPLETED ===");

        vm.stopPrank();
    }

    function testKeeperFeeExceedsCostFactor() public {
        vm.startPrank(owner);

        // Create puppet list
        address[] memory puppetList = new address[](1);
        puppetList[0] = puppet1;

        // Set up matching rule with a small allowance rate
        // TODO: Update when Allocation contract is available in test
        // matchingRule.setRule(
        //     allocation,
        //     USDC,
        //     puppet1,
        //     trader,
        //     MatchingRule.Rule({
        //         allowanceRate: 400, // Only 3% allowance rate (very small)
        //         throttleActivity: 1 hours,
        //         expiry: block.timestamp + 30 days
        //     })
        // );

        // Get current price
        IChainlinkPriceFeedProvider.ValidatedPrice memory price =
            IChainlinkPriceFeedProvider(Const.chainlinkPriceFeedProvider).getOraclePrice(Const.wnt, "");

        // Create position with a very high keeper fee relative to allocation
        MirrorPosition.CallPosition memory callParams = MirrorPosition.CallPosition({
            collateralToken: USDC,
            trader: trader,
            market: Const.gmxEthUsdcMarket,
            keeperFeeReceiver: owner,
            isIncrease: true,
            isLong: true,
            executionFee: 0.001 ether,
            collateralDelta: 100e6,
            sizeDeltaInUsd: 1000e30,
            acceptablePrice: price.min * 110,
            triggerPrice: price.min,
            keeperExecutionFee: 301831, // Very high keeper fee
            allocationId: getNextAllocationId()
        });
        mirrorPosition.requestMirror{value: callParams.executionFee}(matchingRule, callParams, puppetList);

        vm.stopPrank();
    }

    function _getNextContractAddress(
        address user
    ) internal view returns (address) {
        return vm.computeCreateAddress(user, vm.getNonce(user) + 1);
    }

    function _getNextContractAddress(address user, uint count) internal view returns (address) {
        return vm.computeCreateAddress(user, vm.getNonce(user) + count);
    }
}
